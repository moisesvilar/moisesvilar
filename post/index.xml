<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Write some code!</title>
    <link>https://moisesvilar.github.io/post/index.xml</link>
    <description>Recent content in Posts on Write some code!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-ES</language>
    <copyright>&amp;copy; Esta obra está bajo una &lt;a target=&#39;_blank&#39; rel=&#39;license&#39; href=&#39;http://creativecommons.org/licenses/by/4.0/&#39;&gt;Licencia Creative Commons Atribución 4.0 Internacional&lt;/a&gt;.</copyright>
    <lastBuildDate>Fri, 27 Jan 2017 17:18:27 +0100</lastBuildDate>
    <atom:link href="https://moisesvilar.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>docker V - preparando un entorno</title>
      <link>https://moisesvilar.github.io/post/docker-5-environment/</link>
      <pubDate>Fri, 27 Jan 2017 17:18:27 +0100</pubDate>
      
      <guid>https://moisesvilar.github.io/post/docker-5-environment/</guid>
      <description>

&lt;p&gt;El bueno y viejo PHP. Un lenguaje tan &lt;a href=&#34;https://w3techs.com/technologies/overview/programming_language/all&#34;&gt;usado&lt;/a&gt; como &lt;a href=&#34;https://www.google.es/search?q=php+sucks&#34;&gt;vilipendiado&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Pero a mi me gusta.&lt;/p&gt;

&lt;p&gt;Vale que su API ha crecido sin orden ni concierto y a veces te encuentras tantas incongruencias que parece que la han diseñado durante un atracón de cerveza y marihuana.&lt;/p&gt;

&lt;p&gt;Vale que ha sido usado durante años por gente sin formación, o por lo menos sin un mínimo cariño por las cosas bien hechas, y eso lo ha convertido en uno de los referentes del
&lt;a href=&#34;https://es.wikipedia.org/wiki/C%C3%B3digo_espagueti&#34;&gt;código espagueti&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Pero recordad que no hace mucho tiempo lo mismo le pasaba a Javascript. ¡Cuántos atentados al software he visto en Javascript! Y hoy lo tenemos en todos lados e incluso en el 2014 fue nombrado
&lt;a href=&#34;http://www.tiobe.com/tiobe-index/javascript/&#34;&gt;lenguaje del año&lt;/a&gt;. ¡Hasta Liam Neeson está un poco harto del auge de Javascript!&lt;/p&gt;


&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/venganza_javascript_framework.jpg&#34; alt=&#34;¿Otro framework Javascript? Señor, llévanos pronto...&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;¿Otro framework Javascript? Señor, llévanos pronto...&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;PHP es un lenguaje ultra-flexible, cosa que lo convierte en un lenguaje &lt;em&gt;divertido&lt;/em&gt;&amp;hellip; pero que también puede hacer que escribas muy mal código. ¿Culpa del lenguaje o culpa
del desarrollador? Yo la respuesta la tengo clara.&lt;/p&gt;

&lt;p&gt;Y por ello, he decidido tomarlo como framework para ilustar el ejemplo de este artículo: vamos a montar un entorno de desarrollo en PHP sobre Docker.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Let&amp;rsquo;s go!&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;una-pequeña-sorpresa-de-la-docker-machine&#34;&gt;Una pequeña sorpresa de la docker-machine&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Si estáis en un entorno con soporte nativo para Docker, podéis saltar a la siguiente sección.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Arrancad vuestro entorno Docker&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine start default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; conectaros a él&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; y ejecutad lo siguiente:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /
ls -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fijaos en esta carpeta que os marco aquí:&lt;/p&gt;


&lt;figure class=&#34;text-center&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-5-dockermachine-8.jpg&#34; alt=&#34;Una misteriosa carpeta C...&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Una misteriosa carpeta C...&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Mmm. Entrad en ella y veréis que contiene otra carpeta llamada &lt;strong&gt;Users&lt;/strong&gt;. Entrad también en ella y haced un &lt;strong&gt;ls&lt;/strong&gt;. ¡Son vuestras carpetas personales de vuestro equipo Windows!&lt;/p&gt;

&lt;p&gt;En efecto, la máquina virtual tiene una &lt;em&gt;carpeta compartida&lt;/em&gt; con vuestro host Windows que nos facilitará mucho la vida, como veremos al final de este artículo.&lt;/p&gt;

&lt;p&gt;Es más, si abrís directamente la GUI de Virtualbox, podéis ver dicha carpeta seleccionando la máquina virtual, pulsando en configuración y yendo a &amp;ldquo;Carpetas compartidas&amp;rdquo;:&lt;/p&gt;


&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-5-dockermachine-2.jpg&#34; alt=&#34;Carpeta compartida entre nuestro windows y la VM Docker&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Carpeta compartida entre nuestro windows y la VM Docker&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h1 id=&#34;la-distro-alpine&#34;&gt;La distro Alpine&lt;/h1&gt;

&lt;p&gt;Como hemos dicho en posts anteriores, Alpine es una distribución Linux superligera, ocupando menos de 4MB.&lt;/p&gt;

&lt;p&gt;Viene con un gestor de paquetes, llamado &lt;em&gt;apk&lt;/em&gt;, cuyo uso podéis investigar en la &lt;a href=&#34;http://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management&#34;&gt;documentación oficial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Y cuenta con &lt;a href=&#34;https://pkgs.alpinelinux.org/package/v3.3/main/x86/php-apache2&#34;&gt;paquetes para PHP&lt;/a&gt; y para &lt;a href=&#34;https://pkgs.alpinelinux.org/package/edge/main/x86/apache2&#34;&gt;Apache&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Así que supondremos que tenemos un proyecto web programado en PHP con Apache como servidor y todo sobre el sistema operativo Alpine.
¡Montemos su entorno usando Docker!&lt;/p&gt;

&lt;h1 id=&#34;instalando-apache-y-php-en-alpine&#34;&gt;Instalando Apache y PHP en Alpine&lt;/h1&gt;

&lt;p&gt;Muy bien, lancemos un contenedor a partir de la imagen de Alpine en su versión 3.3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -t -i -p 8080:80 --name tom_collins alpine:3.3 /bin/sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Todo nos debería de sonar excepto ese nuevo parámetro &lt;strong&gt;-p 8080:80&lt;/strong&gt;. Con este parámetro lo que
estamos haciendo es &lt;strong&gt;publicar&lt;/strong&gt; el puerto 80 del contenedor en el puerto 8080 del host.
Es decir, Docker publicará todas las peticiones entrantes en el puerto 8080 del host al puerto
80 del contenedor, y publicará todas las respuestas salientes del puerto 80 del contenedor al
puerto 8080 del host. ¿Recordáis como decíamos en &lt;a href=&#34;https://moisesvilar.github.io/post/docker-layers-2/&#34;&gt;este post&lt;/a&gt;
que Docker le asignaba a cada contenedor su propia interfaz de red? Por defecto, dicha interfaz
viene completamente aislada del mundo. Con este comando, estamos abriendo en ella una pequeña ventana.&lt;/p&gt;

&lt;p&gt;Esto nos será útil para probar la instalación desde el host, como haremos en seguida.&lt;/p&gt;

&lt;p&gt;Pero antes, una vez hayamos lanzado el contenedor, ejecutemos en él los siguientes comandos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apk update
apk add apache2 php-apache2
mkdir /run/apache2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Con esto tendremos instalado Apache y PHP en nuestro contenedor. Finalmente, si ejecutamos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;httpd -D FOREGROUND
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;habremos lanzado nuestro servidor Apache.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;No voy a explicar los comandos aquí expuestos, ya que está fuera del alcance
de estos artículos, pero si hay alguna duda: ¡preguntad en los comentarios!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;probando-el-entorno-desde-la-vm-docker&#34;&gt;Probando el entorno desde la VM Docker&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;En un nuevo terminal&lt;/strong&gt; hagamos una conexión a nuestra VM Docker:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y ejecutemos el siguiente comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl localhost:8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Debería de mostrarnos la respuesta HTML que escupe nuestro Apache:&lt;/p&gt;


&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-5-dockermachine-3.jpg&#34; alt=&#34;It&amp;#39;s alive!&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;It&amp;#39;s alive!&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Aunque curl mola, entiendo que no lo veáis muy útil si lo que tenemos que depurar es una aplicación web. ¡Pongámosle solución!&lt;/p&gt;

&lt;h1 id=&#34;configurando-el-reenvío-de-puertos-de-virtualbox&#34;&gt;Configurando el reenvío de puertos de Virtualbox&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Si vuestro sistema posee soporte nativo de Docker, podéis pasar directamente a la siguiente sección.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Abrid el GUI de Virtualbox, haced click derecho sobre la VM Docker e iros a
&lt;strong&gt;Configuración &amp;gt; Red &amp;gt; Avanzadas &amp;gt; Reenvío de puertos&lt;/strong&gt;:&lt;/p&gt;


&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-5-virtualbox-1.jpg&#34; alt=&#34;Reenvío de puertos en Virtualbox&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Reenvío de puertos en Virtualbox&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Y estableced la regla que yo he nombrado &lt;strong&gt;8080&lt;/strong&gt;, tal y como se ve en esta imagen:&lt;/p&gt;


&lt;figure class=&#34;text-cente w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-5-virtualbox-2.jpg&#34; alt=&#34;Reenviando el puerto 8080 de la VM Docker al puerto 80 de nuestra máquina Windows&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Reenviando el puerto 8080 de la VM Docker al puerto 80 de nuestra máquina Windows&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Es decir, reenviad todo lo que salga o entre del puerto 8080 de la VM Docker hacia el puerto 80 de la máquina Windows.&lt;/p&gt;

&lt;h1 id=&#34;probando-el-entorno-desde-la-máquina-anfitrión&#34;&gt;Probando el entorno desde la máquina anfitrión&lt;/h1&gt;

&lt;p&gt;Simplemente abrid un navegador e iros a la URL &lt;strong&gt;localhost&lt;/strong&gt; (o a &lt;strong&gt;localhost:8080&lt;/strong&gt; si vuestra máquina ya tiene soporte nativo
para Docker).&lt;/p&gt;


&lt;figure class=&#34;text-center&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-5-windows-1.jpg&#34; alt=&#34;It&amp;#39;s still alive!&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;It&amp;#39;s still alive!&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;¡Tenemos acceso directo al apache de nuestro contenedor desde nuestra máquina anfitrión!&lt;/p&gt;

&lt;p&gt;Más o menos lo que tenemos es algo parecido a esto:&lt;/p&gt;


&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-5-architecture-1.jpg&#34; alt=&#34;Si estamos utilizando Virtualbox y su reenvío de puertos porque nuestro sistema operativo no tiene soporte nativo para Docker&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Si estamos utilizando Virtualbox y su reenvío de puertos porque nuestro sistema operativo no tiene soporte nativo para Docker&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-5-architecture-2.jpg&#34; alt=&#34;Si nuestro sistema operativo tiene soporte nativo para Docker (un Linux, por ejemplo)&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Si nuestro sistema operativo tiene soporte nativo para Docker (un Linux, por ejemplo)&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Vale, esto empieza a tener mejor pinta si somos desarrolladores web y no nos llamamos &lt;a href=&#34;https://es.wikipedia.org/wiki/Neo_(Matrix)&#34;&gt;Neo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Como ya tenemos nuestro entorno montado, lo que podemos hacer ahora es &lt;em&gt;congelar&lt;/em&gt; el sistema de
ficheros de este contenedor en una nueva imagen y así, cuando tengamos que lanzar nuevos contenedores,
no tendremos que volver a instalar nuestro entorno Alpine + Apache + PHP.&lt;/p&gt;

&lt;p&gt;Recordad que el comando para ello era:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker commit -m &amp;quot;Apache &amp;amp; PHP installed&amp;quot; -a &amp;quot;Moises Vilar&amp;quot; tom_collins moisesvilar/apache_php:alpine3.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A nuestra nueva imagen la he bautizado como &lt;strong&gt;moisesvilar/apache_php:alpine3.3&lt;/strong&gt;. Si ejecutamos un &lt;strong&gt;docker images&lt;/strong&gt;
veréis la nueva imagen creada.&lt;/p&gt;

&lt;p&gt;Si en vez de &lt;strong&gt;moisesvilar&lt;/strong&gt; utilizáis vuestro nombre de usuario en el Docker Hub, podéis utilizar el
siguiente comando para &lt;strong&gt;subir esta imagen a vuestro repositorio público&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker push moisesvilar/apache_php:alpine3.3
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Es posible que os muestre el error &lt;strong&gt;unauthorized: authentication required&lt;/strong&gt;. En ese caso,
basta con ejecutar el comando &lt;strong&gt;docker login&lt;/strong&gt; e introducir nuestras credenciales de Docker Hub&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Fijaros en el resultado del comando &lt;strong&gt;docker push&lt;/strong&gt;:&lt;/p&gt;


&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-5-push-1.jpg&#34; alt=&#34;Resultado de ejecutar docker push sobre nuestra imagen&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Resultado de ejecutar docker push sobre nuestra imagen&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;¿Véis que ha subido &lt;strong&gt;dos capas&lt;/strong&gt;? ¡Claro! La capa de alpine y la capa de lectura/escritura donde
hemos instalado Apache + PHP.&lt;/p&gt;

&lt;p&gt;Vamos a limpiar un poco el entorno eliminando todos nuestros contenedores:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker rm $(docker ps -aq)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;y también &lt;strong&gt;vamos a eliminar todas nuestras imagenes&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker rmi $(docker images -q)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A continuación vamos a seguir modificando nuestro entorno para poder picar nuestros
ficheros de código desde nuestra máquina anfitrión (con nuestro IDE preferido) y que estos
se &lt;em&gt;compartan&lt;/em&gt; directamente en el directorio correcto en el contenedor Alpine + Apache + PHP.&lt;/p&gt;

&lt;h1 id=&#34;volúmenes-entre-el-host-y-los-contenedores&#34;&gt;Volúmenes entre el host y los contenedores&lt;/h1&gt;

&lt;p&gt;La situación a la que queremos llegar es la siguiente:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Queremos escribir el código en nuestro equipo, donde tenemos las herramientas que más nos gusten,
generalmente un IDE como Netbeans, WebStorm, Eclipse (si te van las drogas duras) o Notepad++ (si
le llamamos IDE a cualquier cosa).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Queremos que dicho código esté automáticamente disponible en el interior de nuestro contenedor,
en la carpeta correspondiente.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Queremos ver el resultado a través de un navegador instalado en nuestro equipo, porque los
desarrolladores tenemos esa manía: nos gusta probar las cosas, ver si están rotas y en cuyo caso, arreglarlas.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;El punto 3 lo hemos solventado a partir de la publicación de puertos, tal y como hemos visto en las
secciones anteriores.&lt;/p&gt;

&lt;p&gt;Para el segundo punto, tenemos que utilizar un nuevo parámetro del comando &lt;strong&gt;docker run&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -v /c/Users/Moises/workspace:/var/www/localhost/htdocs -p 80:80 moisesvilar/apache_php:alpine3.3 httpd -D FOREGROUND
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unos pequeños comentarios:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Veis que no he utilizado los parámetros &lt;strong&gt;-t -i&lt;/strong&gt;, sino el parámetro &lt;strong&gt;-d&lt;/strong&gt; (de &lt;em&gt;dettached&lt;/em&gt;
o &lt;em&gt;daemon&lt;/em&gt;): quiero que el contenedor se ejecute en &lt;em&gt;background&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Veis que he publicado el puerto 80 del contenedor en el puerto 80 del host (el ejemplo anterior,
donde utilizaba el puerto 8080 del host, sólo era ilustrativo). &lt;strong&gt;Recordad cambiar el reenvío de puertos
en vuestro Virtualbox, si estáis utilizando la Docker machine&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Veis que no he usado el parámetro &lt;strong&gt;- -name&lt;/strong&gt;: Docker bautizará automáticamente a nuestro contenedor.&lt;/li&gt;
&lt;li&gt;Veis que la instrucción que se va a ejecutar no es /bin/sh sino &lt;strong&gt;httpd -D FOREGROUND&lt;/strong&gt;: queremos
que lance nuestro servidor una vez arranque el contenedor.&lt;/li&gt;
&lt;li&gt;Cuando ejecutéis el comando, al haber eliminado todas nuestras imágenes, Docker no encontrará
la imagen moisesvilar/apache_php:alpine3.3, pero no hay problema: ya que la hemos subido al Docker
Hub, &lt;strong&gt;la descargará automáticamente&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ahora fijaos en el parámetro &lt;strong&gt;-v /c/Users/Moises/workspace:/var/www/localhost/htdocs&lt;/strong&gt;.
Lo que estamos haciendo es &lt;em&gt;montar&lt;/em&gt; directamente el contenido de mi carpeta local
C:/Users/Moises/workspace en el directorio /var/www/localhost/htdocs de mi contenedor.
Este último directorio es a donde va a ir nuestro Apache para servir los ficheros que allí
almacenemos.&lt;/p&gt;

&lt;p&gt;A esto se le llama &lt;strong&gt;crear un volumen del contenedor&lt;/strong&gt;. En este caso, el contenido del volumen es el
contenido de un directorio de nuestro host.&lt;/p&gt;

&lt;p&gt;Para demostraros cómo funciona, lo que he hecho es irme a esa carpeta local (si no existiese, la crearía) y he creado allí
un archivo &lt;strong&gt;index.php&lt;/strong&gt;:&lt;/p&gt;


&lt;figure class=&#34;text-center&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-5-windows-2.jpg&#34; alt=&#34;Un archivo index.php en mi directorio workspace&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Un archivo index.php en mi directorio workspace&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;El contenido de este archivo es una sencilla aplicación web que podéis descargar
desde &lt;a href=&#34;https://github.com/moisesvilar/docker-vi-ws&#34;&gt;su repositorio en Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Si ahora abrimos un navegador y vamos a la URL &lt;strong&gt;localhost/index.php&lt;/strong&gt; ¡alehop! ¡Ahí tenemos nuestra
pequeña aplicación web &lt;em&gt;up and running&lt;/em&gt;!&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/DEhf8U8NEN0&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;Probad a hacer una pequeña modificación en el código (añadid un elemento más HTML, por ejemplo, para mostrar algún texto),
guardad el fichero y recargad la página: ¡los cambios debería reflejarse automáticamente en el navegador!&lt;/p&gt;

&lt;h1 id=&#34;sacándole-partido&#34;&gt;Sacándole partido&lt;/h1&gt;

&lt;p&gt;Haced el ejercicio mental de complicar la situación. Imaginad que estáis trabajando en varios proyectos, cada uno en distintas
tecnologías. Por ejemplo:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nuestro proyecto web en PHP.&lt;/li&gt;
&lt;li&gt;Una API Rest en NodeJS.&lt;/li&gt;
&lt;li&gt;Una página web HTML + CSS + Javascript sobre un servidor Ngix.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;¡No tenemos porqué tener instalados todos esos componentes en nuestra máquina local! Simplemente necesitamos tres contenedores
con los entornos instalados. Incluso podríamos tener los tres ejecutándose al mismo tiempo, siempre y cuando publiquemos los
puertos correspondientes a cada contenedor en un puerto &lt;strong&gt;distinto&lt;/strong&gt; de nuestro host.&lt;/p&gt;

&lt;p&gt;Por ejemplo, podemos tener nuestro proyecto web en PHP accesible desde la URL localhost:9000, nuestro proyecto NodeJS en
localhost:9001 y nuestro proyecto web en HTML en localhost:9002.&lt;/p&gt;

&lt;p&gt;Ahora se incorpora otro programador al equipo. ¿Tienes que instalarle los tres entornos en su máquina? ¡Por supuesto que no!
Le instalas Docker, ejecutas los tres comandos &lt;strong&gt;docker run&lt;/strong&gt; correspondientes&amp;hellip; ¡y a trabajar!&lt;/p&gt;

&lt;p&gt;Por el momento, este planteamiento sólo es válido &lt;strong&gt;en desarrollo&lt;/strong&gt;. Pero veremos dentro de pocas semanas que es supersencillo
crear una imagen con nuestro código dentro de una capa de dicha imagen. Por lo que la puesta en producción se reduce a&amp;hellip; ¡Exacto!
¡Otra ejecución del comando &lt;strong&gt;docker run&lt;/strong&gt; correspondiente! ¡Olvídate del RedBull para las traumáticas puestas en producción!&lt;/p&gt;

&lt;p&gt;Espero que le vayáis viendo las ventajas a este nuevo paradigma, porque estoy convencido de que ha llegado para quedarse. Se llame
Docker o con otro nombre comercial, pero el planteamiento es muy, muy interesante.&lt;/p&gt;

&lt;p&gt;Avisados quedáis :)&lt;/p&gt;

&lt;h1 id=&#34;un-pequeño-ejercicio&#34;&gt;Un pequeño ejercicio&lt;/h1&gt;

&lt;p&gt;Recordáis como en &lt;a href=&#34;https://moisesvilar.github.io/post/docker-layers-2/&#34;&gt;este post&lt;/a&gt; hablábamos del concepto de &amp;ldquo;capas reutilizables&amp;rdquo;
y dibujábamos nuestras arquitecturas &amp;ldquo;apilando&amp;rdquo; capas (la del sistema operativo, encima de ésta la de NodeJS y encima
de ésta la de ExpressJS).&lt;/p&gt;

&lt;p&gt;Pero también hemos dicho hoy que la imagen que hemos creado sólo contiene dos capas
(la del sistema operativo, Alpine en nuestro caso, y otra más que contiene los binarios de Apache + PHP). Lo vimos
al subir dicha imagen al Docker Hub.&lt;/p&gt;

&lt;p&gt;Si ahora creásemos otra imagen donde no necesitásemos la capa de PHP, sino únicamente la de Apache en la misma versión
que tenemos instalada en nuestra imagen, &lt;strong&gt;¿el UFS podría reutilizarla?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Si vuestra respuesta es &lt;em&gt;NO&lt;/em&gt;, &lt;strong&gt;¿qué procedimiento deberíamos haber seguido para que dicha capa fuese realmente reutilizable por el UFS?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;¡Id poniendo vuestras respuestas/análisis/conjeturas en los comentarios! Si por lo menos hay un comentario sobre el tema,
daré la respuesta la semana que viene ;)&lt;/p&gt;

&lt;h1 id=&#34;conclusiones&#34;&gt;Conclusiones&lt;/h1&gt;

&lt;p&gt;¡Hey, chic@s! ¿Veis lo que hemos conseguido? ¡Tenemos un entorno de desarrollo dockerizado para nuestros proyectos Apache + PHP!&lt;/p&gt;

&lt;p&gt;¿Qué pasaría si ahora un rayo cayese sobre mi equipo y éste ardiese hasta convertise en cenizas?&lt;/p&gt;

&lt;p&gt;Pues lo primero, me tendría que comprar otro equipo.&lt;/p&gt;

&lt;p&gt;Lo segundo, ejecutaría un &lt;strong&gt;git clone&lt;/strong&gt; para descargarme mi último &lt;em&gt;push&lt;/em&gt; del código dentro de mi carpeta /c/Users/Moises/workspace.&lt;/p&gt;

&lt;p&gt;Y por último, ejecutaría:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -v /c/Users/Moises/workspace:/var/www/localhost/htdocs -p 80:80 moisesvilar/apache_php:alpine3.3 httpd -D FOREGROUND
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;¡Y listo! Mi entorno estaría perfectamente arrancado y configurado para seguir con mi proyecto.&lt;/p&gt;

&lt;p&gt;Cosas que hemos visto hoy:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;La Docker machine comparte automáticamente tus carpetas personales con su VM Docker.&lt;/li&gt;
&lt;li&gt;Cómo instalar Apache y PHP en una distro Alpine.&lt;/li&gt;
&lt;li&gt;Cómo reenviar puertos entre Virtualbox y nuestro host (la VM Docker).&lt;/li&gt;
&lt;li&gt;Como publicar puertos entre nuestro host y nuestro contenedor con el comando &lt;strong&gt;-p&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Cómo subir nuestras imágenes al Docker hub con el comando &lt;strong&gt;docker push&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Cómo eliminar imágenes descargadas en nuestro equipo con el comando &lt;strong&gt;docker rmi&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Cómo lanzar nuestros contenedores en modo &lt;em&gt;dettached&lt;/em&gt; con el parámetro &lt;strong&gt;-d&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Cómo montar un directorio de nuestro host automáticamente en nuestro contenedor con el parámetro &lt;strong&gt;-v&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;¡Y de bonus, un meme y chistes de Chuck Norris! ¡No os quejéis!&lt;/p&gt;

&lt;p&gt;Nos vemos dentro de nada. En el siguiente post vamos a introducir los &lt;strong&gt;Dockerfiles&lt;/strong&gt;, para poder automatizar
la prepación de entornos y convertirlos directamente en imágenes.&lt;/p&gt;

&lt;p&gt;P.S. Recordad que pulsando en los botones que tenéis arriba de todo que pone &amp;ldquo;Facebook&amp;rdquo;, &amp;ldquo;Twitter&amp;rdquo; y &amp;ldquo;Google+&amp;rdquo;
me ayudáis a difundir el blog, que seamos más por aquí y que esto sea más divertido. ¡Muchas gracias!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>docker IV - manejando contenedores</title>
      <link>https://moisesvilar.github.io/post/docker-4-containers/</link>
      <pubDate>Sun, 15 Jan 2017 14:10:02 +0100</pubDate>
      
      <guid>https://moisesvilar.github.io/post/docker-4-containers/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Como al final del &lt;a href=&#34;https://moisesvilar.github.io/post/docker-basics-1/&#34;&gt;anterior post&lt;/a&gt;, os recomiendo que tengáis el ordenador a mano mientras
leeis. ¡Hoy toca picar muchos comandos!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Muy bien, chic@s. Vamos a ver un par de comandos más de la Docker machine y nos pondremos
ya de inmediato a lanzar nuestros contenedores.&lt;/p&gt;

&lt;h1 id=&#34;estado-de-nuestra-vm-docker&#34;&gt;Estado de nuestra VM Docker&lt;/h1&gt;

&lt;p&gt;En el &lt;a href=&#34;https://moisesvilar.github.io/post/docker-basics-1/&#34;&gt;anterior post&lt;/a&gt; lo habíamos dejado con nuestra
máquina virtual Docker (que habíamos llamado &lt;em&gt;default&lt;/em&gt;) &lt;em&gt;up and running&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Pero entiendo que desde entonces hasta ahora, habéis apagado el equipo. Por lo que si ejecutáis&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;veremos que el estado de nuestra máquina es &lt;em&gt;stopped&lt;/em&gt;.&lt;/p&gt;


&lt;figure class=&#34;text-center&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-4-commands-1.jpg&#34; alt=&#34;Nuestra VM Docker descansando de un día duro de trabajo&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Nuestra VM Docker descansando de un día duro de trabajo&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Para lanzarla basta con ejecutar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine start default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tardará un poco (lamentablemente, estamos lanzando toda una máquina virtual, y aunque ligera,
lleva su tiempo). Pero finalmente tendremos nuestra máquina en estado &lt;em&gt;running&lt;/em&gt;:&lt;/p&gt;


&lt;figure class=&#34;text-center&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-4-commands-2.jpg&#34; alt=&#34;Nuestra VM Docker up and running&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Nuestra VM Docker up and running&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;También decir que, de una manera similar, podemos detenerla con el siguiente comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine stop default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por último, nos conectamos a nuestra VM para poder operar bajo un sistema que tenga soporte
nativo para Docker:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Con nuesto host Docker ya ejecutándose y conectados a él, pasamos a lanzar contenedores!&lt;/p&gt;

&lt;h1 id=&#34;lanzando-nuestro-primer-contenedor&#34;&gt;Lanzando nuestro primer contenedor&lt;/h1&gt;

&lt;p&gt;Lancemos nuestro primer contenedor a partir de la imagen de alpine que ya deberíamos
tener descargada si hemos seguido lo indicado en el &lt;a href=&#34;https://moisesvilar.github.io/post/docker-basics-1/&#34;&gt;anterior post&lt;/a&gt;.
Y antes de darle un &lt;em&gt;enter&lt;/em&gt;, poned el cronómetro:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -t -i --name bloody_mary alpine /bin/sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;¿Cuánto ha tardado en lanzar el contenedor? ¿Medio milisegundo? :)&lt;/p&gt;

&lt;p&gt;Desgranemos el comando:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;docker run&lt;/em&gt;: le indicamos al intérprete de Docker que vamos a ejecutar un comando &lt;em&gt;run&lt;/em&gt;, que se
traduce por un &amp;ldquo;lánzame un contenedor&amp;rdquo;. Esto es, se conectará vía HTTPS e invocará los métodos de la API
REST necesarios para que el servidor Docker realice esta tarea.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;-t&lt;/em&gt;: le indicamos que nos habilite un terminal tty para ese contenedor.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;-i&lt;/em&gt;: le indicamos que queremos interactuar con el contenedor, es decir, que lo lance en modo interactivo.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;ndash;name bloody_mary&lt;/em&gt;: le asignamos el nombre &lt;em&gt;bloody_mary&lt;/em&gt; a nuestro contenedor. Si no especificamos
este parámetro, Docker escogerá uno por nosotros. Y como curiosidad, en &lt;a href=&#34;https://github.com/docker/docker/blob/master/pkg/namesgenerator/names-generator.go&#34;&gt;Github&lt;/a&gt;
tenéis el código en Go de esta tarea.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;alpine&lt;/em&gt;: le indicamos que queremos que use la imagen alpine como sistema de directorios de nuestro
contenedor.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;/bin/sh&lt;/em&gt;: por último, le indicamos qué proceso queremos que ejecute cuando lance nuestro contenedor.
En este caso, que ejecute el &lt;em&gt;shell&lt;/em&gt;. Como hemos habilitado una terminal tty y estamos en modo interactivo,
la ejecución de este comando nos devolverá un &lt;em&gt;prompt&lt;/em&gt; a nuesro contenedor, como si nos acabáramos de conectar
por SSH.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;El apasionante resultado de la ejecución de este comando, a continuación:&lt;/p&gt;


&lt;figure class=&#34;text-center&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-4-commands-3.jpg&#34; alt=&#34;Un precioso prompt a nuestro contenedor alpine&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Un precioso prompt a nuestro contenedor alpine&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Ejecutad un &lt;em&gt;ls&lt;/em&gt;. Ahí lo tenéis. Los binarios de la distribución alpine.&lt;/p&gt;


&lt;figure class=&#34;text-center&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-4-commands-8.jpg&#34; alt=&#34;La distribución alpine en todo su esplendor&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;La distribución alpine en todo su esplendor&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Ahora teclead &lt;em&gt;exit&lt;/em&gt; y dadle un &lt;em&gt;enter&lt;/em&gt; para salir de nuestro contenedor y volver a nuestra VM Docker.&lt;/p&gt;

&lt;p&gt;Para listar los contenedores, ejecutamos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Un momento&amp;hellip; parece que la lista está vacía:&lt;/p&gt;


&lt;figure class=&#34;text-center&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-4-commands-4.jpg&#34; alt=&#34;¿Dónde está nuestro recién lanzado contenedor?&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;¿Dónde está nuestro recién lanzado contenedor?&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Lo que ha pasado aquí es sencillo de entender. Al ejecutar &lt;em&gt;exit&lt;/em&gt; no sólo hemos salido de nuestro contenedor,
sino que &lt;strong&gt;hemos finalizado el proceso /bin/sh que se ejecutaba en él&lt;/strong&gt;. No había ningún otro proceso en
&lt;em&gt;foreground&lt;/em&gt; ejecutándose en dicho contenedor, por lo tanto éste directamente se ha detenido.&lt;/p&gt;

&lt;p&gt;Podemos verlo con la opción -a (&lt;em&gt;all&lt;/em&gt;, es decir, los que se están ejecutando y los que no) del anterior comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahí lo tenemos. Si os fijáis en la columna &lt;em&gt;STATUS&lt;/em&gt;, nos indica que hemos salido hace 24 segundos:&lt;/p&gt;


&lt;figure class=&#34;text-center&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-4-commands-5.jpg&#34; alt=&#34;¡Aquí estaba!&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;¡Aquí estaba!&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Otro parámetro para el comando &lt;em&gt;ps&lt;/em&gt; es &lt;em&gt;-q&lt;/em&gt;, que nos lista únicamente la columna &lt;em&gt;CONTAINER ID&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps -a -q
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Volvamos a lanzar nuestro contenedor a partir de nuestra imagen de alpine e insertemos una modificación en su sistema de ficheros:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; docker start bloody_mary
&amp;gt; docker exec -t -i bloody_mary /bin/sh
/ # echo &amp;quot;Sin tele y sin cerveza, Homer pierde la cabeza!&amp;quot; &amp;gt; sabiduria.txt
/ # exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Con la primera línea, &lt;strong&gt;docker start bloody_mary&lt;/strong&gt; estamos relanzando nuestro contenedor (que, recordemos, estaba detenido).&lt;/p&gt;

&lt;p&gt;Pero fijaros que en esta ocasión Docker no nos devuelve el &lt;em&gt;prompt&lt;/em&gt; a nuestro contenedor.&lt;/p&gt;

&lt;p&gt;Para poder abrir ahora un terminal a nuestro contenedor ejecutamos la segunda línea &lt;strong&gt;docker exec -t -i bloody_mary /bin/sh&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Es decir, ejecuta el comando &lt;em&gt;/bin/sh&lt;/em&gt; en el contenedor &lt;em&gt;bloody_mary&lt;/em&gt; con un terminal tty y en modo interactivo.&lt;/p&gt;

&lt;p&gt;Ahora sí que estamos dentro de nuestro contedor.&lt;/p&gt;

&lt;p&gt;Pues bien, con la tercera línea lo que hacemos es crear un fichero &lt;em&gt;sabiduria.txt&lt;/em&gt; cuyo contenido será &lt;em&gt;&amp;ldquo;Sin tele y sin cerveza, Homer pierde la cabeza!&amp;rdquo;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Y por último, salimos del contenedor. Como hemos visto antes, esto hará que el contenedor se detenga.&lt;/p&gt;

&lt;p&gt;Pero si volvemos a entrar y listamos el contenido del directorio raíz haciendo un &lt;em&gt;ls&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; docker exec -t -i bloody_mary /bin/sh
/ # ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veremos que nuestro fichero &lt;em&gt;sabiduria.txt&lt;/em&gt; sigue estando ahí.&lt;/p&gt;

&lt;p&gt;Como habíamos dicho en post anteriores,la capa de lectura/escritura es persistente &lt;strong&gt;siempre y cuando no eliminemos el contenedor, sólo lo detengamos&lt;/strong&gt;,
como es el caso.&lt;/p&gt;

&lt;p&gt;Ahora eliminemos nuestro contenedor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker stop bloody_mary
docker rm 1a6b2d03fa14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El &lt;em&gt;numeraco&lt;/em&gt; 1a6b2d03fa14 se corresponde precisamente con el CONTAINER ID del contenedor que queremos borrar.&lt;/p&gt;

&lt;p&gt;Si queremos eliminar todos nuestros contenedores, ejecutándose o no, de una tacada, podemos hacer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker rm $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es decir, al comando &lt;strong&gt;docker rm&lt;/strong&gt; le concatenamos la salida del comando &lt;strong&gt;docker ps -a -q&lt;/strong&gt; que nos devolverá
todos los CONTAINER ID de todos nuestros contenedores.&lt;/p&gt;

&lt;p&gt;Volvamos a crear un contenedor a partir de nuestra imagen de alpine, en modo iteractivo, con un
terminal tty y ejecutando el proceso /bin/sh para que nos sitúe el &lt;em&gt;prompt&lt;/em&gt; dentro de nuestro contenedor.
Y a continuación, hagamos un &lt;em&gt;ls&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; docker run -t -i --name bloody_mary alpine /bin/sh
/ # ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vemos que ahora no hay ningún fichero &lt;em&gt;sabiduria.txt&lt;/em&gt;. ¡Evidentemente! Hemos eliminado el contenedor anterior,
eliminando a su vez su capa de lectura/escritura.&lt;/p&gt;

&lt;p&gt;Al lanzar el nuevo, utiliza la imagen alpine para su sistema de ficheros&amp;hellip; ¡y crea una nueva capa de lectura/escritura
limpia y reluciente y sin rastro del fichero &lt;em&gt;sabiduria.txt&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;¿Cómo podemos incorporar esa capa? Pues convirtiendo el sistema de ficheros de ese contenedor en
una nueva imagen, precisamente lo que vamos a hacer a continuación.&lt;/p&gt;

&lt;h1 id=&#34;creando-nuevas-imágenes&#34;&gt;Creando nuevas imágenes&lt;/h1&gt;

&lt;p&gt;Repetimos proceso: creamos un contenedor a partir de la imagen de alpine y modificamos su
capa de lectura/escritura:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; docker run -t -i --name tequila_sunrise alpine /bin/sh
/ # echo &amp;quot;Sin tele y sin cerveza, Homer pierde la cabeza!&amp;quot; &amp;gt; sabiduria.txt
/ # exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahora ejecutamos el siguiente comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker commit -m &amp;quot;A new awesome cocktail&amp;quot; -a &amp;quot;Moises Vilar&amp;quot; tequila_sunrise moisesvilar/alpine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este comando crea una nueva imagen con nombre &lt;strong&gt;moisesvilar/alpine&lt;/strong&gt; (utilizad si queréis vuestro nombre de usuario en Docker hub,
en vez de &lt;em&gt;moisesvilar&lt;/em&gt;) cuyo autor es &lt;em&gt;&amp;ldquo;Moisés Vilar&amp;rdquo;&lt;/em&gt; y con un mensaje de creación &lt;em&gt;&amp;ldquo;A new awesome cocktail&amp;rdquo;&lt;/em&gt; a partir del sistema de ficheros que
actualmente posee el contenedor &lt;strong&gt;tequila_sunrise&lt;/strong&gt;, incluyendo su capa de lectura y escritura.&lt;/p&gt;

&lt;p&gt;Si ahora ejecutamos&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;veremos que nuestra imagen se ha creado correctamente:&lt;/p&gt;


&lt;figure class=&#34;text-center&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-4-commands-6.jpg&#34; alt=&#34;Nuestra nueva imagen moisesvilar/alpine&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Nuestra nueva imagen moisesvilar/alpine&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Bien, pues ejecutemos un nuevo contenedor a partir de esta imagen y hagamos un &lt;em&gt;ls&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; docker run -t -i --name old_fashioned moisesvilar/alpine /bin/sh
/ # ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;¡Ahí tenemos nuestro fichero &lt;em&gt;sabiduria.txt&lt;/em&gt;!&lt;/p&gt;


&lt;figure class=&#34;text-center&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-4-commands-7.jpg&#34; alt=&#34;Nuestro fichero sabiduria.txt existe en el nuevo contenedor creado a partir de la imagen moisesvilar/alpine&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Nuestro fichero sabiduria.txt existe en el nuevo contenedor creado a partir de la imagen moisesvilar/alpine&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Lo que hemos hecho es &amp;ldquo;congelar&amp;rdquo; el sistema de ficheros del contenedor &lt;strong&gt;tequila_sunrise&lt;/strong&gt;, creando una nueva imagen
que, ahora sí, incorpora una capa que contiene el fichero &lt;em&gt;sabiduria.txt&lt;/em&gt; y, a continuación, hemos creado
el contenedor &lt;strong&gt;old_fashioned&lt;/strong&gt; a partir de dicha imagen.&lt;/p&gt;

&lt;h1 id=&#34;conclusiones&#34;&gt;Conclusiones&lt;/h1&gt;

&lt;p&gt;¡Por fin tenéis comandos! En este post hemos aprendido un buen puñado de cosas:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hemos visto cómo controlar el estado de nuestra VM Docker (nuestro &lt;em&gt;host&lt;/em&gt; para Docker) con los comandos
&lt;strong&gt;docker-machine start&lt;/strong&gt; y &lt;strong&gt;docker-machine stop&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Hemos lanzado nuestro primer contenedor con el comando &lt;strong&gt;docker run&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Hemos listado nuestos contenedores con el comando &lt;strong&gt;docker ps&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Los hemos iniciado y detenido con los comandos &lt;strong&gt;docker start&lt;/strong&gt; y &lt;strong&gt;docker stop&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Los hemos eliminado con el comando &lt;strong&gt;docker rm&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Hemos ejecutado procesos en contenedores previamente iniciados, con el comando &lt;strong&gt;docker exec&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Hemos creado una imagen a partir del sistema de ficheros de un contenedor con el comando &lt;strong&gt;docker commit&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Si queréis bucear más a fondo en estos comandos, podéis recurrir a la &lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/&#34;&gt;referencia oficial de Docker&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Por el momento, nosotros lo dejamos aquí. En el siguiente post montaremos una imagen &amp;ldquo;a mano&amp;rdquo; con
un entorno de ejecución (quizás PHP o quizás NodeJS, aún no lo tengo decidido, si tenéis alguna
preferencia&amp;hellip; dejadla en los comentarios!).&lt;/p&gt;

&lt;p&gt;¡Nos vemos en nada!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>docker III - docker hub, docker machine</title>
      <link>https://moisesvilar.github.io/post/docker-concepts-3/</link>
      <pubDate>Thu, 12 Jan 2017 20:49:11 +0100</pubDate>
      
      <guid>https://moisesvilar.github.io/post/docker-concepts-3/</guid>
      <description>

&lt;p&gt;En este post veremos los últimos acordes antes de ponernos a tocar la sinfonía. Lo dividiré en dos partes.
En la primera, describiremos dos conceptos que nos serán útiles a la hora de trabajar con Docker.
En la segunda, haremos un pequeño tutorial de cómo instalar Docker en sistemas sin soporte nativo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vamos allá!&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;últimos-conceptos-por-ahora&#34;&gt;Últimos conceptos&amp;hellip; por ahora&lt;/h1&gt;

&lt;p&gt;Veremos dos de ellos: el Docker Hub y la Docker machine.&lt;/p&gt;

&lt;h2 id=&#34;docker-hub&#34;&gt;Docker Hub&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://moisesvilar.github.io/post/docker-layers-2/&#34;&gt;En el anterior post&lt;/a&gt; vimos el concepto de &lt;strong&gt;imágenes&lt;/strong&gt;
como un conjunto de capas que forman los binarios de nuestros entornos (por ejemplo, CentOS 7 +
NodeJS 6.9). Pues bien, estas imágenes pueden ser subidas a un repositorio gestionado por
los chicos de Docker. Esto es el Docker Hub.&lt;/p&gt;

&lt;p&gt;Allí encontrarás una gigantesca cantidad de imágenes ya creadas por otras personas
alrededor del mundo. Algunas de ellas tienen la etiqueta de &lt;em&gt;oficial&lt;/em&gt;: han sido creadas y son
mantenidas por los chicos que están detrás del desarrollo de dichos binarios. Por ejemplo,
puedes encontrar imágenes oficiales para entornos con NodeJS.&lt;/p&gt;

&lt;p&gt;Al Docker Hub se puede acceder a través de la siguiente URL: &lt;a href=&#34;https://hub.docker.com/&#34;&gt;https://hub.docker.com/&lt;/a&gt;.
Hace falta registrarse, pero es gratuíto y no tardarás más de un minuto.&lt;/p&gt;

&lt;p&gt;Una vez lo hayas hecho, en el cuadro de búsqueda puedes probar a introducir &amp;ldquo;node&amp;rdquo;. El primer resultado
está catalogado como &lt;em&gt;oficial&lt;/em&gt;. Si lo inspeccionamos, veremos que esta imagen está disponible
con varios &lt;em&gt;tags&lt;/em&gt;: para la versión 7.4, 6.9, 4.7&amp;hellip;&lt;/p&gt;

&lt;p&gt;Fijaos en aquellos &lt;em&gt;tags&lt;/em&gt; que terminan con &lt;em&gt;alpine&lt;/em&gt; y buscad dicha imagen. Alpine
es una distribución de Linux que viene con lo básico y que ocupa la friolera de &lt;strong&gt;2 MB&lt;/strong&gt; (comprimido) y &lt;strong&gt;4 MB&lt;/strong&gt; (sin comprimir). Comparadlo
con el peso de la imagen de CentOS (70MB): si montamos nuestros entornos a partir de Alpine
(siempre y cuando una decisión de diseño no nos impida hacerlo), montando sobre él todo lo que necesitemos
(un Apache, una JVM etc.) nos libraremos de 68MB de &lt;em&gt;overhead&lt;/em&gt; y nuestras imágenes serán
muy livianas.&lt;/p&gt;

&lt;p&gt;Fijaos ahora, entrando en cualquier imagen, en el recuadro de la derecha, titulado &lt;em&gt;Docker Pull Command&lt;/em&gt;:
exacto, el Docker Hub está implementado como un SaaS y podremos descargar imágenes a través de su API.
Concretamente, el comando &lt;em&gt;docker pull&lt;/em&gt; nos permitirá hacer esto sobre línea de comandos.&lt;/p&gt;

&lt;p&gt;Docker Hub, como hemos dicho, es gratuíto y su modelo de negocio es muy parecido a Github: con tu
cuenta gratuíta, todas tus imágenes serán públicas. Si deseas que sean privadas, tienes que pasar
por caja.&lt;/p&gt;

&lt;h2 id=&#34;docker-machine&#34;&gt;Docker machine&lt;/h2&gt;

&lt;p&gt;Como hemos dicho anteriormente, Docker necesita que el sistema operativo de la máquina anfitrión
tenga la capacidad de utilizar chroot, cgroups y namespaces. Esto lo cumple cualquier sistema operativo
basado en Unix (Linux o MacOS), Windows Server y Windows 10 Professional.&lt;/p&gt;

&lt;p&gt;Pero para versiones anteriores hay que instalar el paquete conocido como &lt;em&gt;Docker Toolbox&lt;/em&gt;
(lo veremos en la siguiente sección).&lt;/p&gt;

&lt;p&gt;Dentro de este paquete se encuentra la &lt;em&gt;Docker machine&lt;/em&gt;: es una máquina virtual ligera (~20MB)
basada en Linux. Una vez arrancada, dentro de ella tendremos soporte nativo para Docker y podremos
ejecutar nuestros comandos para descargar imágenes, lanzar contenedores etc.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Id pensando en una cuestión. Si estamos en Windows 10 Home y hemos instalado la Docker machine, para Docker
¿quién es el host? ¿La máquina física con Windows 10? ¿O la VM que nos proporciona Docker machine? La respuesta, al final del post :)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;instalación-de-docker-en-sistemas-sin-soporte-nativo&#34;&gt;Instalación de Docker en sistemas sin soporte nativo&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Un consejo: a partir de aquí os recomiendo que leais esto desde un PC y que intentéis seguir los pasos a medida que vayáis leyendo.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;En primer lugar, necesitamos descargarnos el paquete &lt;a href=&#34;https://www.docker.com/products/docker-toolbox&#34;&gt;Docker Toolbox&lt;/a&gt;.
Con él, entre otras herramientas, nos vendrá la Docker machine y Virtualbox, que es el motor de virtualización
que utilizaremos para crear nuestra pequeña máquina virtual Linux que &lt;strong&gt;sí&lt;/strong&gt; tenga soporte nativo para Docker.&lt;/p&gt;

&lt;p&gt;Ahora, tenemos dos caminos.&lt;/p&gt;

&lt;p&gt;El más fácil es hacer doble click en el acceso directo que tendremos en el escritorio
(si así lo hemos marcado durante la instalación) y se iniciará el proceso de creación de la máquina virtual de la que hablamos.&lt;/p&gt;

&lt;p&gt;Pero como sé que os gusta picar comandos, lo haremos de esta manera.&lt;/p&gt;

&lt;p&gt;Abrid un terminal, cmd o como queráis llamarle. Y por favor, no uséis el nativo de Windows. Descargaros algo como
&lt;a href=&#34;https://conemu.github.io/&#34;&gt;ConEmu&lt;/a&gt; o &lt;a href=&#34;http://cmder.net/&#34;&gt;cmder&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Si picamos&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine create -d virtualbox default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;crearemos una máquina virtual de nombre &lt;em&gt;default&lt;/em&gt; utilizando el driver para &lt;em&gt;Virtualbox&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Una vez finalizada la ejecución de este comando, si picamos&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;veremos un listado de nuestras máquinas virtuales creadas:&lt;/p&gt;


&lt;figure class=&#34;w70 text-center&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-3-commands-1.jpg&#34; alt=&#34;Resultados de docker-machine ls&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Resultados de docker-machine ls&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Por el momento, sólo fijaos en la columna &lt;em&gt;STATE&lt;/em&gt;, que nos indica que la máquina está ejecutándose.&lt;/p&gt;

&lt;p&gt;Si ahora hacemos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;estableceremos una conexión SSH con nuestra máquina. Ahora ya estamos dentro de una máquina con soporte nativo para Docker. Concretamente, una distribución
Linux (llamada &lt;em&gt;Boot2Docker&lt;/em&gt;) superligera para que el impacto en nuestro equipo sea mínimo.&lt;/p&gt;

&lt;p&gt;Antes de terminar, vamos a ejecutar un par de comandos más:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker login
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Esta es la primera vez que vamos a ejecutar el programa &lt;em&gt;docker&lt;/em&gt;. Tened siempre presente que lo que hace este ejecutable es conectarse a través de
HTTPS al docker-agent e invocar los métodos de su API REST.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Con este comando podemos hacer login en el &lt;em&gt;Docker hub&lt;/em&gt; para poder descargar nuevas imágenes. Nos pedirá nuestro nombre de usuario y contraseña, y ya
los tendremos porque ya hemos creado la cuenta al comienzo de este post, ¿verdad? ¿VERDAD? ;)&lt;/p&gt;

&lt;p&gt;Ahora vamos a buscar imágenes a través del SaaS que proporciona &lt;em&gt;Docker hub&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker search alpine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nos devolverá el listado de imágenes cuyo nombre, descripción&amp;hellip; contenga la cadena &lt;em&gt;alpine&lt;/em&gt;. Podéis comprobar que son los mismos resultados que obtuvimos
en la primera parte de este post, cuando lo buscamos manualmente a través de la interfaz web del &lt;em&gt;Docker hub&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Muy bien, pues vamos a descargarnos la imagen oficial para alpine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker pull alpine:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Con &lt;em&gt;:latest&lt;/em&gt;, le estamos indicando que se descargue la imagen cuya &lt;strong&gt;etiqueta&lt;/strong&gt; sea &lt;em&gt;latest&lt;/em&gt;. Este es el comportamiento por defecto si no especificamos ninguna
etiqueta.&lt;/p&gt;

&lt;p&gt;Tardará como cosa de dos pestañeos (ocupa 4MB, ¿recordáis?), así que tendréis que estar atentos para daros cuenta de que en algún momento la salida por pantalla nos pone algo como
&lt;em&gt;Pulling layer&lt;/em&gt;. ¡Exacto! Al descargar la imagen, nos estamos descargando todas las capas que la componen. En este caso, la imagen de alpine sólo cuenta con
una capa, la que contiene los binarios de este sistema operativo.&lt;/p&gt;

&lt;p&gt;Para listar las imágenes que tenemos descargadas en nuestro sistema:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veremos aquí nuestra imagen alpine recién descargada. Fijaos en la columna &lt;em&gt;SIZE&lt;/em&gt;. 3.984MB. Veis que no os mentía: todo un Linux funcional en menos de 4MB.&lt;/p&gt;


&lt;figure class=&#34;text-center&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-3-commands-2.jpg&#34; alt=&#34;Salida del comando docker images, con nuestra imagen alpine de apenas 4MB :)&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Salida del comando docker images, con nuestra imagen alpine de apenas 4MB :)&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h1 id=&#34;conclusiones&#34;&gt;Conclusiones&lt;/h1&gt;

&lt;p&gt;En este pequeño post hemos visto los conceptos de &lt;em&gt;Docker hub&lt;/em&gt; y &lt;em&gt;Docker machine&lt;/em&gt;. Hemos instalado Docker en un sistema no nativo (Windows 10 Home, por ejemplo) y ¡ole! hemos
picado nuestros primeros comandos para &lt;em&gt;loguearnos&lt;/em&gt; en el Docker hub, buscar imágenes, descargarlas y listar las que tengamos descargadas en nuestra máquina.&lt;/p&gt;

&lt;p&gt;En el siguiente post nos pondremos serios: empezamos a lanzar contenedores.&lt;/p&gt;

&lt;p&gt;¡Nos vemos en nada!&lt;/p&gt;

&lt;p&gt;P.S. La respuesta a la pregunta que os hacía más arriba: el host en ese caso es &lt;strong&gt;la máquina virtual que proporciona Docker machine&lt;/strong&gt;, que es la que
tiene las herramientas necesarias para que Docker funcione (chroot, cgroups y namespaces)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>docker II - capas e imágenes</title>
      <link>https://moisesvilar.github.io/post/docker-layers-2/</link>
      <pubDate>Tue, 10 Jan 2017 19:51:45 +0100</pubDate>
      
      <guid>https://moisesvilar.github.io/post/docker-layers-2/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://moisesvilar.github.io/post/docker-basics-1/&#34;&gt;En el anterior post&lt;/a&gt; vimos que una de las herramientas heredadas de Unix que utilizaba Docker eran los chroot.
Con ellos, podíamos establecer para un proceso &lt;strong&gt;en qué directorio comenzaba su sistema de ficheros&lt;/strong&gt;, su &lt;em&gt;carpeta raíz&lt;/em&gt;. También dijimos que, en la gestión de dicho sistema de ficheros,
Docker era bastante eficiente.&lt;/p&gt;

&lt;p&gt;En este post veremos en qué consiste esta eficiencia y cómo la consigue Docker.&lt;/p&gt;

&lt;h1 id=&#34;las-capas&#34;&gt;Las capas&lt;/h1&gt;

&lt;p&gt;Imaginémonos que tenemos dos entornos de ejecución para dos aplicaciones.
Ambos se ejecutan sobre el sistema operativo CentOS 7. Pero la primera,
es una aplicación basada en la API 6 de Java. Porque somos tipos duros. Y la segunda es
una aplicación NodeJS 6.9.&lt;/p&gt;

&lt;p&gt;Vamos a hacer el ejercicio mental de montar sendos entornos de ejecución en dos máquinas virtuales.&lt;/p&gt;

&lt;p&gt;Para la &lt;strong&gt;primera máquina virtual&lt;/strong&gt;, la que reproduce el entorno de ejecución de la aplicación Java,
tendremos que instalar:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;El sistema operativo CentOS 7.&lt;/li&gt;
&lt;li&gt;La máquina virtual de Java para la versión 6 de su API.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Para la &lt;strong&gt;segunda máquina virtual&lt;/strong&gt;, la de la aplicación NodeJS:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;El sistema operativo CentOS 7 &lt;em&gt;again&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;El servidor NodeJS en su versión 6.9.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Fijaos en el primer punto de ambas máquinas, el sistema operativo CentOS 7.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;¿Todos los ficheros binarios que componen dicho sistema operativo están duplicados en ambas máquinas?&lt;/strong&gt;
Por supuesto que sí.&lt;/p&gt;

&lt;p&gt;Tendríamos algo como esto:&lt;/p&gt;


&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-2-vm-1.jpg&#34; alt=&#34;Entorno en cada máquina virtual&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Entornos independientes (y duplicados) en dos máquinas virtuales&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Esto no parece que sea muy eficiente. Es decir, ambas máquinas duplican &lt;strong&gt;exactamente&lt;/strong&gt; los mismos
binarios para el sistema operativo.&lt;/p&gt;

&lt;p&gt;¿Qué pasaría si dichos binarios se pudiesen &lt;strong&gt;reutilizar&lt;/strong&gt; entre ambas máquinas? En este escenario,
ganaríamos eficiencia, ya que ambas máquinas compartirían los ficheros del sistema operativo
(al fin y al cabo, es el mismo para ambos entornos). La única condición que necesitaríamos es que
dichos binarios fueran de &lt;strong&gt;sólo lectura&lt;/strong&gt;, para evitar que una escritura de la primera máquina
cambiase el entorno de la segunda y ésta se fuese al garete.&lt;/p&gt;

&lt;p&gt;En este segundo caso tendríamos:&lt;/p&gt;


&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-2-vm-2.jpg&#34; alt=&#34;Entorno compartido en dos máquinas virtuales&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Entorno teórico de dos máquinas virtuales que comparten y reutilizan partes del mismo, en este caso, el sistema operativo&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Bien, ahora bauticemos las cosas. Resulta que a un conjunto de binarios (por ejemplo, los que
componen el sistema operativo CentOS 7) se le denomina &lt;strong&gt;una capa&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Este concepto de &lt;strong&gt;capas reutilizables&lt;/strong&gt; es lo que emplea Docker para ganar eficiencia entre
las &amp;ldquo;máquinas virtuales&amp;rdquo; (con todas las comillas que queráis) que gestiona. Es decir, la arquitectura
de capas que emplearía Docker para modelizar los entornos del ejemplo sería la de la segunda figura,
reutilizando la capa del sistema operativo. Y sí, sería de sólo lectura, y aunque parezca un
impedimento grande, no lo es tanto, como veremos más adelante.&lt;/p&gt;

&lt;p&gt;Si resulta que ahora necesitamos un tercer entorno, por ejemplo una aplicación web sobre CentOS 7 y
NodeJS 6.9 pero empleando el framework Express 4, podríamos reutilizar las capas anteriores y
nuestra nueva arquitectura quedaría de la siguiente forma:&lt;/p&gt;


&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-2-vm-3.jpg&#34; alt=&#34;Entorno compartido en dos máquinas virtuales&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Entornos de tres máquinas virtuales que comparten y reutilizan partes: sistema operativo, servidor de aplicaciones etc.&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;¿Vemos la idea?&lt;/p&gt;

&lt;p&gt;¿Y cómo se llama el chico que gestiona todo esto de reutilización de capas en Docker para que no se descontrole
entre distintos entornos virtualizados? El &lt;strong&gt;Union File System&lt;/strong&gt; (UFS). Y no me voy a meter a fondo
con esto, más que nada, porque no lo controlo y no quiero meter la pata. Pero también porque, por el momento,
no me ha hecho falta saber cómo funciona exactamente el UFS para entender Docker y poder trabajar con él.&lt;/p&gt;

&lt;p&gt;Aunque, si estás leyendo esto y eres un experto en este tema, ¡no te cortes! Déjanos algo en los comentarios.&lt;/p&gt;

&lt;p&gt;Por el momento continuamos con el siguiente concepto.&lt;/p&gt;

&lt;h1 id=&#34;las-imágenes&#34;&gt;Las imágenes&lt;/h1&gt;

&lt;p&gt;Una imagen en Docker es &lt;strong&gt;cualquier conjunto vertical y adyacente de capas&lt;/strong&gt;. Es decir, en
la arquitectura de la figura anterior podríamos definir las siguientes imágenes:&lt;/p&gt;


&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-2-im-1.jpg&#34; alt=&#34;Imágenes posibles en la arquitectura de capas anterior&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Imágenes posibles en una arquitectura de capas&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;ol&gt;
&lt;li&gt;Una imagen con la capa de CentOS 7.&lt;/li&gt;
&lt;li&gt;Una imagen con la capa de JRE 6 sobre la de CentOS 7.&lt;/li&gt;
&lt;li&gt;Una imagen con la capa de NodeJS 6.9 sobre la de CentOS 7.&lt;/li&gt;
&lt;li&gt;Una imagen con la capa de Express 4, sobre la de NodeJS 6.9, ésta a su vez sobre la de CentOS 7.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cada una de estas imágenes &lt;strong&gt;servirá como sistema de directorios de nuestras &amp;ldquo;máquinas virtuales&amp;rdquo;&lt;/strong&gt;,
teniendo en cuenta que:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Las imágenes son de &lt;strong&gt;solo lectura&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;El UFS controla, para cada &amp;ldquo;máquina virtual&amp;rdquo;, si alguna de las capas de su imagen está siendo usada por
otra &amp;ldquo;máquina virtual&amp;rdquo;, y si es el caso, &lt;strong&gt;la reutiliza&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;¿Y si ahora queremos ejecutar una aplicación en alguno de nuestros entornos? Fácil: simplemente será
una capa más a añadir encima de nuestra arquitectura. Es decir, los ficheros del aplicación componen
una nueva capa que es gestionada por el UFS. Por ejemplo, para nuestra aplicación Express sobre NodeJS:&lt;/p&gt;


&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-2-im-2.jpg&#34; alt=&#34;Imagen de una aplicación Express sobre NodeJS&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Imagen de una aplicación Express sobre NodeJS&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Pero habíamos dicho que nuestras imágenes son de sólo lectura. Entonces, ¿qué pasa cuando nuestra
aplicación realiza una escritura a disco (en un fichero, o en una base de datos)?&lt;/p&gt;

&lt;p&gt;Para responder a esta pregunta hay que introducir el siguiente concepto (y último, por hoy).&lt;/p&gt;

&lt;h1 id=&#34;los-contenedores&#34;&gt;Los contenedores&lt;/h1&gt;

&lt;p&gt;Os habréis dado cuenta del uso de las comillas cuando escribo &amp;ldquo;máquina virtual&amp;rdquo;. Además de porque ya
sabemos que en Docker no existe este concepto exactamente, ya que se trata de una virtualización ligera,
el otro motivo es que en Docker el término que se utiliza es el de &lt;strong&gt;contenedor&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Un contenedor es uno de esos procesos aislados y limitados en recursos de los que hablábamos
&lt;a href=&#34;https://moisesvilar.github.io/post/docker-basics-1/&#34;&gt;en el anterior post&lt;/a&gt; y cuyo sistema de ficheros también
le indicábamos. Como adelantamos arriba, el sistema de ficheros que va a utilizar ese proceso
(o ya podemos llamarlo &lt;em&gt;contenedor&lt;/em&gt;) será la imagen que le indiquemos: la de CentOS 7, la de
CentOS 7 + Java etc.&lt;/p&gt;

&lt;p&gt;Cuando lanzamos un contenedor en Docker, ademas de crear dicho proceso, le añade a su imagen
&lt;strong&gt;una nueva capa de lectura/escritura&lt;/strong&gt; que es donde realizará las modificaciones que se
efectúen durante la ejecución del contenedor. Por último, también le asigna una interfaz de
red virtual, para que el contenedor se pueda comunicar con el resto del mundo.&lt;/p&gt;

&lt;p&gt;En esa capa de lectura/escritura es donde el proceso ve una versión concreta de los ficheros
que son modificados. De esta manera, el estado de ejecución entre distintos contenedores que
usen la misma imagen se mantiene independiente entre ambos, y esto permite al UFS poder reutilizar
el resto de capas entre el resto de contenedores que las usen en sus imágenes.&lt;/p&gt;

&lt;p&gt;¿Más o menos queda claro?&lt;/p&gt;

&lt;p&gt;Un contenedor no es más que un proceso aislado y limitado en recursos que sólo ve como
sistema de ficheros lo que la imagen le proporciona, más esa capa de lectura/escritura que
guarda su estado actual.&lt;/p&gt;

&lt;p&gt;Y fijaos: &lt;strong&gt;es un proceso&lt;/strong&gt;. No es una máquina virtual. El lanzamiento de un contenedor es
&lt;strong&gt;rapidísimo&lt;/strong&gt;. Del orden de milisegundos. ¿Cuánto tiempo tardas en iniciar una máquina virtual
con Virtualbox o VMWare? ¿Un par de minutos? ¿Unas cuantas decenas de segundos si tu máquina es potente?
Pues eso.&lt;/p&gt;

&lt;p&gt;Como todos los procesos, los contenedores se pueden pausar, se pueden reiniciar y se pueden &lt;em&gt;matar&lt;/em&gt; definitivamente.
Si los pausamos/reiniciamos, la capa de lectura/escritura permanece intacta entre ambos estados. Pero,
si &lt;em&gt;matamos&lt;/em&gt; un contenedor y volvemos a lanzar uno nuevo a partir de la misma imagen, la capa
de lectura/escritura habrá desaparecido. ¡Claro, es un contenedor nuevo!&lt;/p&gt;

&lt;p&gt;Así que ésta no es la manera adecuada de crear una capa de persistencia usando contenedores Docker.
Pero esto lo veremos en posts futuros cuando presentemos el concepto de volúmenes.&lt;/p&gt;

&lt;h1 id=&#34;conclusiones&#34;&gt;Conclusiones&lt;/h1&gt;

&lt;p&gt;Bueno, la cosa ya se empieza a poner interesante. Hemos visto:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Que Docker usa un sistema de capas, gobernado por el UFS, de tal manera que es capaz de
reutilizarlas si varios contenedores hacen uso de las mismas.&lt;/li&gt;
&lt;li&gt;Que un conjunto de esas capas componen una imagen, que es lo que utilizará Docker para
indicarle qué sistema de ficheros puede ver un determinado contenedor.&lt;/li&gt;
&lt;li&gt;Que los contenedores en Docker no son más que procesos aislados, limitados, con un sistema
de ficheros basado en una imagen, con una capa extra de lectura/escritura que guarda su estado y
con su propia interfaz de red para comunicarse con el resto del mundo.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ya queda poco para que empecemos a picar comandos, que sé que lo estáis deseando:
crearemos imágenes y lanzaremos contenedores. Pero antes vendrá otro post para definir
unos cuantos conceptos sueltos que me han quedado en el tintero junto con un pequeño tutorial
de cómo instalar Docker en máquinas sin soporte nativo para él.&lt;/p&gt;

&lt;p&gt;¡Nos vemos dentro de nada!&lt;/p&gt;

&lt;p&gt;P.S. Resulta que la imagen de cabecera de este post es el reflejo de un &lt;a href=&#34;http://www.lavozdegalicia.es/noticia/carballo/camarinas/2017/01/10/adios-coidos-costa-da-morte/0003_201701C10C7994.htm&#34;&gt;delito contra el patrimonio natural&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>docker I - lo básico</title>
      <link>https://moisesvilar.github.io/post/docker-basics-1/</link>
      <pubDate>Thu, 05 Jan 2017 09:53:15 +0100</pubDate>
      
      <guid>https://moisesvilar.github.io/post/docker-basics-1/</guid>
      <description>

&lt;p&gt;Hace un par de años, cuando trabajaba en el &lt;a href=&#34;https://citius.usc.es/&#34;&gt;CITIUS&lt;/a&gt;,
&lt;a href=&#34;https://twitter.com/jety_fr&#34;&gt;David Martínez&lt;/a&gt; nos impartió un pequeño seminario de una
herramienta con la que había empezado a trastear hacía poco y lo tenía entusiasmado.&lt;/p&gt;

&lt;p&gt;O bien porque no le presté mucha atención (lo siento, David, no eres tú, soy yo) o bien
porque no supe entender su potencial en aquel momento, pero dejé aquello a un lado y me
desentendí un poco de todo ese &amp;ldquo;nuevo&amp;rdquo; mundo.&lt;/p&gt;

&lt;p&gt;Pero hace un año, más o menos, me llamó la atención el curso de &lt;a href=&#34;http://capside-academy.usefedora.com/p/docker-devops&#34;&gt;Docker Essentials&lt;/a&gt;
alojado en &lt;a href=&#34;http://capside-academy.usefedora.com/&#34;&gt;Capside Academy&lt;/a&gt;. Además, lo impartía el
señor Javi Moreno, un verdadero crack con el que tuve el honor de dar mis primeros pasos en Javascript
a partir de un curso que también impartió en el &lt;a href=&#34;https://cntg.xunta.es/web/cnt/home&#34;&gt;CNTG&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Si a Javi le apasionaba Docker, entonces la cosa tenía que ser interesante.&lt;/p&gt;

&lt;p&gt;Así que desempolvé los apuntes que nos había facilitado David y cuando pude sacar algo de tiempo (en realidad, pasaron muchos meses desde que descubrí el curso),
me lo devoré de cabo a rabo. Además, en paralelo, en el podcast de &lt;a href=&#34;http://wedevelopers.com/&#34;&gt;WeDevelopers&lt;/a&gt;
emitieron un capítulo de, exacto&amp;hellip; &lt;a href=&#34;http://wedevelopers.com/2016/11/12/we-developers-046-docker/&#34;&gt;Javi Moreno hablando de Docker!&lt;/a&gt;.
El universo me estaba enviando una señal, no cabía duda.&lt;/p&gt;

&lt;p&gt;Puedo afirmar con una mano en el corazón que desde el primer momento en el que empecé a cacharrear con Docker ya tenía claro que lo
iba a implantar en &lt;a href=&#34;https://www.tecalis.com/&#34;&gt;Tecalis&lt;/a&gt;. Ahora mismo lo estamos utilizando para nuestros entornos de desarrollo
y ahora mismo estamos estudiando cómo prepararlo para nuestros entornos de preproducción.&lt;/p&gt;

&lt;p&gt;Aunque mi experiencia con Docker no es exhaustiva, ni larga, creo que los conceptos básicos
me han quedado bastante claros, así que voy a intentar plasmarlos aquí con el objetivo de ahorrarle
un par de horas a cualquiera que quiera comenzar con ello.&lt;/p&gt;

&lt;p&gt;Por otro lado, si eres un experto y ves que estoy metiendo la pata hasta el fondo&amp;hellip; vapuléame
en los comentarios! Sin piedad, en serio.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Empezamos!&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;para-qué-se-usa-docker&#34;&gt;¿Para qué se usa Docker?&lt;/h1&gt;

&lt;p&gt;En el 2010, la persona que había gestionado durante trece años el mantenimiento y evolución de
un importante sistema de información de la Xunta de Galicia decidió que era un buen momento
para cambiar de aires. Así que pidió la cuenta y se fué. Y como yo pasaba por allí, &lt;del&gt;me cayó el marrón&lt;/del&gt; me ofrecieron esa responsabilidad.&lt;/p&gt;

&lt;p&gt;Repito: un sistema desarrollado durante trece años. Cuando se picó su primera línea de código,
no existía Google. Cuando yo lo cogí, el iPhone llevaba tres añitos entre nosotros. Os podéis hacer
una idea.&lt;/p&gt;

&lt;p&gt;El caso es que el entorno de desarrollo de dicho sistema era, cuanto menos&amp;hellip; caótico. Mil
dependencias en forma de librerías, algunas open source, otras código propietario, algunas obsoletas,
otras directamente demasiado exóticas o desconocidas&amp;hellip;&lt;/p&gt;

&lt;p&gt;Ignorando temas de mantenibilidad, (que es decir mucho, ya lo sé, pero sólo tenía un añito
de experiencia laboral!), el primer problema con el que me encontré es que dicho entorno de desarrollo
estaba perfectamente instalado y configurado&amp;hellip; en un único equipo. Como en los años 50, cuando
queríamos/necesitábamos realizar una mejora, implementar un cambio, corregir un bug&amp;hellip; un compañero
se movía físicamente a dicho equipo durante los días que hiciese falta (es decir, dejaba su
puesto de trabajo habitual durante días para irse a picar código a otro equipo que no era el suyo, a unas oficinas
que no eran de su empresa y con unos compañeros que no eran los suyos) para implementar la nueva
versión del sistema. Lo compilaba allí mismo, y enviaba los ejecutables por FTP al cabecilla de
turno para que los desplegase.&lt;/p&gt;

&lt;p&gt;Y procurábamos no pensar, por nuestra salud mental, qué pasaría si por alguna razón dicho
equipo ardía o era zapateado escaleras abajo. Todavía se me ponen los pelos de punta.&lt;/p&gt;

&lt;p&gt;Una locura.&lt;/p&gt;

&lt;p&gt;Como comentaba, era un sistema bastante importante (aunque no lo parezca) así que las presiones
por tener implementadas mejoras y correcciones eran prácticamente constantes todo el año. Estaba
descartada la idea de hacer un trabajo &amp;ldquo;forense&amp;rdquo; e intentar replicar el estado de dicho equipo de
desarrollo en otra máquina. Así que opté por utilizar una herramienta de VMWare
(el &lt;a href=&#34;http://www.vmware.com/products/converter.html&#34;&gt;vCenter Converter&lt;/a&gt;) que, básicamente,
escaneaba un sistema de ficheros entero alojado en una máquina física y lo convertía en una máquina
virtual. De esta manera, virtualicé (a cañonazos) el equipo de desarrollo, me lo metí en una memoria
externa y, oye, por lo menos podíamos dormir tranquilos: ya teníamos una copia virtual del entorno
de desarrollo, que podíamos ejecutar donde quisiéramos (siempre y cuando el equipo anfitrión
fuera lo suficientemente potente) y los desarrolladores ya no tenían que estar trabajando entre dos
sitios distintos. Quiero pensar que su calidad de vida incrementó enteros en aquel momento.&lt;/p&gt;

&lt;p&gt;¿Por qué os cuento esta historia? Porque Docker te permite, entre otras cosas,
&lt;strong&gt;replicar exactamente&lt;/strong&gt; el entorno de ejecución de un proyecto, de una manera muchísimo más
eficiente y rápida que la que buenamente implementé yo con el vCenter Converter. Eso sí, con matices
que iremos viendo paulatinamente.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;En realidad, si no empiezas tu proyecto usando Docker, puede ser bastante complicado replicar su
 entorno de ejecución a posteriori. Es más, en la historia que os cuento, sería como mínimo una tarea complicada y tediosa.
 Pero estas cosas las comentaremos más adelante en posts futuros.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Imaginad que puedo desplegar un entorno de ejecución de cualquier sistema/aplicación en un tiempo
ridículo (del orden de milisegundos) y siendo lo más eficiente posible en el uso de recursos. Pues eso es Docker.&lt;/p&gt;

&lt;p&gt;Partiendo de esto, podéis intuir que el paso de desarrollo a producción es indoloro (adiós a
aquello de &lt;em&gt;¡en mi máquina funcionaba!&lt;/em&gt;). En todos los escenarios (desarrollo, testing, preproducción, producción&amp;hellip;) tenemos exactamente
el mismo entorno (el mismo sistema operativo, la misma base de datos, las mismas librerías&amp;hellip; todo
en las versiones exactas). El margen para los problemas se estrecha bastante.&lt;/p&gt;

&lt;h1 id=&#34;todo-eso-está-muy-bien-pero-cómo-funciona&#34;&gt;Todo eso está muy bien, pero ¿cómo funciona?&lt;/h1&gt;

&lt;p&gt;En realidad, la tecnología que está en las tripas de Docker no es el último grito precisamente.
Emplea herramientas que llevan con nosotros muchos, muchos años. Si eres un experto en entornos
Unix, seguramente te suenen. Yo no lo soy, así que me sonaban vagamente cuando empecé con Docker.&lt;/p&gt;

&lt;p&gt;En Unix tenemos desde hace muchos años las siguientes funcionalidades:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://es.wikipedia.org/wiki/Chroot&#34;&gt;chroot&lt;/a&gt;: básicamente le indica a un proceso que su
sistema de ficheros empieza donde tú le digas. Es decir, cambias la raíz del sistema de ficheros
del proceso (de ahí su nombre, &lt;em&gt;change root&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cgroups&#34;&gt;cgroups&lt;/a&gt;: se utiliza para limitar en recursos la
ejecución de un proceso: memoria, ancho de banda, núcleos etc. categorizando los procesos en diferentes &lt;em&gt;control groups&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man7/namespaces.7.html&#34;&gt;namespaces&lt;/a&gt;: útiles para aislar un proceso
del resto de procesos. Es decir, poder hacerle creer a un proceso que es el único que se está
ejecutando en toda la máquina.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pues perfecto, si ejecutamos un proceso aislado, limitado en recursos y le decimos que la raíz
de su sistema de ficheros está en un directorio donde tenemos almacenados casualmente los binarios de nuestro
entorno de ejecución (sistema operativo, base de datos, servidor de aplicaciones etc), &lt;em&gt;alehop!&lt;/em&gt;,
&lt;strong&gt;acabamos de virtualizar dicho entorno a nivel de sistema operativo&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Y esto es la idea principal de Docker: virtualización ligera a nivel de sistema operativo.
Usando procesos pequeños y rápidos en vez de pesadas máquinas virtuales. Y siendo muy eficientes
en los binarios que componen nuestro entorno de ejecución, como veremos en futuros posts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Estas son las tripas de Docker. La verdad detrás del truco, que necesitamos saber para no
caer en lo que comentaba el bueno de Arthur C. Clarke: &lt;em&gt;cualquier tecnología lo suficientemente
avanzada es indistinguible de la magia&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Pero para nuestro día a día, lo único que tenemos que tener claro es que Docker maneja la siguiente
arquitectura:&lt;/p&gt;


&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/docker-architecture.jpg&#34; alt=&#34;arquitectura de docker&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Modelo de componentes (muy simplificado) de Docker&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Es decir, tenemos un &lt;strong&gt;intérprete de Docker&lt;/strong&gt;, el &lt;em&gt;docker client&lt;/em&gt;, que se comunica con el sistema Docker
(el &lt;em&gt;docker server&lt;/em&gt;) a través de una API REST bajo HTTPS cuyo punto de acceso está implementado
en el proceso &lt;em&gt;docker agent&lt;/em&gt; que se ejecuta en background.&lt;/p&gt;

&lt;p&gt;Con cada comando que ejecutamos en Docker, por ejemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -ti alpine /bin/sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;en realidad estamos invocando una o varias peticiones HTTPS a dicha API REST. ¡Incluso podríamos
comunicarnos con ella directamente empleando cURL por ejemplo!&lt;/p&gt;

&lt;p&gt;Es el &lt;em&gt;docker agent&lt;/em&gt; el encargado de procesar dicha llamada y comunicarse con el núcleo de Docker para que gestione la virtualización
de nuestros entornos utilizando las tres herramientas Unix que veíamos más arriba.&lt;/p&gt;

&lt;p&gt;Por último, decir que la máquina anfitrión, desde el punto de vista de Docker, es aquella que ejecuta
directamente el &lt;em&gt;docker server&lt;/em&gt;. Y para ello, el sistema operativo anfitrión debe &lt;strong&gt;soportar Docker de forma
nativa&lt;/strong&gt;. ¿Esto qué significa? Pues sencillamente, que tiene que implementar algo parecido a los &lt;em&gt;chroots&lt;/em&gt;,
&lt;em&gt;cgroups&lt;/em&gt; y &lt;em&gt;namespaces&lt;/em&gt; que veíamos más arriba. Es decir, tiene que darle las herramientas necesarias a Docker
para que éste haga su magia.&lt;/p&gt;

&lt;p&gt;Por el momento, basta con decir que cualquier sistema basado en Unix (Linux, MacOS) tiene soporte nativo de Docker. Y Windows 10 lo tiene en su versión
Professional, aunque he de decir que mi experiencia por el momento me dice que está bastante verde. Para el resto de
sistemas operativos (Windows 10 Home, Windows 8.1, Windows 7&amp;hellip;) habrá que utilizar un pequeño atajo para poder trabajar con Docker. ¡Pero no adelantemos acontecimientos!
Simplemente sabed que se puede.&lt;/p&gt;

&lt;h1 id=&#34;conclusiones&#34;&gt;Conclusiones&lt;/h1&gt;

&lt;p&gt;Lo sé. No ha sido un post muy exhaustivo, no tenemos código, ni comandos, ni sabemos cómo trabajar con Docker. Pero me
parece interesante asentar bien los conceptos básicos para lo que viene después. Lo que hemos visto aquí:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Docker te permite replicar entornos de ejecución en base a virtualización ligera a nivel de sistema operativo. Eso nos permite terminar de raíz con el problema de &lt;em&gt;¡en mi máquina funciona!&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Para realizar esa virtualización ligera, se apoya en tres herramientas que tenemos en Unix desde casi siempre: chroot, cgroups y namespaces, creando procesos aislados, limitados en recursos y que manejan un sistema de archivos que nosotros les decimos.&lt;/li&gt;
&lt;li&gt;Docker está implementado como una API REST sobre HTTPS. Cuando ejecutamos un comando, lo que realmente hacemos es invocar un método de esa API REST y Docker, tras el telón, hace su magia.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Por último, os invito de nuevo a escuchar el podcast de &lt;a href=&#34;http://wedevelopers.com/2016/11/12/we-developers-046-docker/&#34;&gt;Javi Moreno hablando de Docker!&lt;/a&gt; en WeDevelopers.
Y a realizar su curso de &lt;a href=&#34;http://capside-academy.usefedora.com/p/docker-devops&#34;&gt;Docker Essentials&lt;/a&gt; en Capside-Academy. Son sólo 20€ y os aseguro que estarán
bien invertidos. Así a todo, de vez en cuando publican algún código promocional a través de &lt;a href=&#34;https://twitter.com/capside&#34;&gt;su cuenta de Twitter&lt;/a&gt;.
También es altamente recomendable seguir a &lt;a href=&#34;https://twitter.com/ciberado&#34;&gt;Javi en Twitter&lt;/a&gt; o poner su blog &lt;a href=&#34;https://programar.cloud/&#34;&gt;Programar en Cloud&lt;/a&gt; en tu lector de RSS favorito (y de paso, el mío también!). Habla de Docker,
microservicios, testing&amp;hellip; y un montón de cosas interesantes.&lt;/p&gt;

&lt;p&gt;¡Nos vemos en el siguiente post!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bienvenida</title>
      <link>https://moisesvilar.github.io/post/bienvenida/</link>
      <pubDate>Wed, 04 Jan 2017 13:43:24 +0100</pubDate>
      
      <guid>https://moisesvilar.github.io/post/bienvenida/</guid>
      <description>

&lt;h1 id=&#34;quién-soy&#34;&gt;Quién soy&lt;/h1&gt;

&lt;p&gt;Mi nombre es Moisés Vilar. Soy desarrollador desde los 12 años y desde hace 9 me pagan por ello, actualmente en &lt;a href=&#34;https://www.tecalis.com/&#34;&gt;Tecalis&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;En este blog intentaré escribir sobre las cosas que fui aprendiendo durante mi carrera profesional pero también sobre temas
que estoy empezando a descubrir ahora.&lt;/p&gt;

&lt;p&gt;En definitiva, hablaremos sobre desarrollo web, Javascript, HTML5, NodeJS, MongoDB, Docker&amp;hellip;&lt;/p&gt;

&lt;p&gt;Cualquier consulta, duda, sugerencia, molestia, queja, dolor&amp;hellip; no te cortes en dejarme un comentario en este blog
o contactar conmigo a través de &lt;a href=&#34;https://twitter.com/moisvilar&#34;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;


&lt;figure class=&#34;text-center w100&#34;&gt;
    
        &lt;img src=&#34;https://moisesvilar.github.io/images/keep-calm-and-write-some-code.jpg#medium-image&#34; alt=&#34;Keep calm and write some code&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;&lt;strong&gt;Bienvenidos!&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>